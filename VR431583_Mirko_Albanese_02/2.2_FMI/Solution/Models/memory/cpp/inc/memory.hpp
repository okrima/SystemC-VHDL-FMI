// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 2017.05.1-antlia
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#ifndef MEMORY_HH
#define MEMORY_HH

#include <hif_verilog_standard.hh>
#include <stdint.h>
#include <string>

class memory
{

public:

    bool result_rdy_old;
    uint16_t result_old;
    uint16_t accelerometer_old;
    bool oeb_old;
    bool we_n_old;
    bool sync_old;
    bool vpab_old;
    uint8_t datao_old;
    uint16_t addr_old;
    bool rst_old;
    bool clk_old;
    struct memory_iostruct{
        bool clk;
        bool rst;
        uint16_t addr;
        uint8_t datai;
        uint8_t datao;
        bool irq_n;
        bool nmi_n;
        bool sob_n;
        bool res_n;
        bool rdy;
        bool vpab;
        bool sync;
        bool we_n;
        bool oeb;
        uint16_t accelerometer;
        uint16_t data;
        bool data_rdy;
        uint16_t result;
        bool result_rdy;

        memory_iostruct():
            clk(false),
            rst(false),
            addr(uint16_t(0U)),
            datai(uint8_t(0U)),
            datao(uint8_t(0U)),
            irq_n(false),
            nmi_n(false),
            sob_n(false),
            res_n(false),
            rdy(false),
            vpab(false),
            sync(false),
            we_n(false),
            oeb(false),
            accelerometer(uint16_t(0U)),
            data(uint16_t(0U)),
            data_rdy(false),
            result(uint16_t(0U)),
            result_rdy(false)
        {}

        memory_iostruct( const bool clk_0, const bool rst_0, const uint16_t addr_0,
             const uint8_t datai_0, const uint8_t datao_0, const bool irq_n_0, const
             bool nmi_n_0, const bool sob_n_0, const bool res_n_0, const bool rdy_0,
             const bool vpab_0, const bool sync_0, const bool we_n_0, const bool
             oeb_0, const uint16_t accelerometer_0, const uint16_t data_0, const
             bool data_rdy_0, const uint16_t result_0, const bool result_rdy_0 
            ):
            clk(clk_0),
            rst(rst_0),
            addr(addr_0),
            datai(datai_0),
            datao(datao_0),
            irq_n(irq_n_0),
            nmi_n(nmi_n_0),
            sob_n(sob_n_0),
            res_n(res_n_0),
            rdy(rdy_0),
            vpab(vpab_0),
            sync(sync_0),
            we_n(we_n_0),
            oeb(oeb_0),
            accelerometer(accelerometer_0),
            data(data_0),
            data_rdy(data_rdy_0),
            result(result_0),
            result_rdy(result_rdy_0)
        {}

        ~memory_iostruct()
        {}

        bool operator == (const memory_iostruct & other) const
        {
            if (clk != other.clk) return false;
            if (rst != other.rst) return false;
            if (addr != other.addr) return false;
            if (datai != other.datai) return false;
            if (datao != other.datao) return false;
            if (irq_n != other.irq_n) return false;
            if (nmi_n != other.nmi_n) return false;
            if (sob_n != other.sob_n) return false;
            if (res_n != other.res_n) return false;
            if (rdy != other.rdy) return false;
            if (vpab != other.vpab) return false;
            if (sync != other.sync) return false;
            if (we_n != other.we_n) return false;
            if (oeb != other.oeb) return false;
            if (accelerometer != other.accelerometer) return false;
            if (data != other.data) return false;
            if (data_rdy != other.data_rdy) return false;
            if (result != other.result) return false;
            if (result_rdy != other.result_rdy) return false;
            return true;
        }
    };
    memory_iostruct hif_a2t_data;
    bool data_mspw[16L];
    bool datai_mspw[8L];
    uint8_t state;
    uint8_t state_sig_var;
    uint8_t ram[32768L];
    uint8_t rom[8192L];
    bool memory_addr_switch;
    uint16_t memory_addr;
    memory();


    ~memory();


    bool data_mspw_new[16L];
    bool datai_mspw_new[8L];
    uint8_t state_new;
    bool process_in_queue;
    bool flag_initial_process_executed;
    bool flag_process_executed;
    bool flag_state;
    bool flag_process_1_executed;
    bool flag_clk;
    bool flag_addr;
    bool flag_datai_mspw;
    bool flag_data_mspw;
    bool flag_process_0_process_2_executed;

    void initial_process();


    void process();


    void process_1();


    void datai_mspw_proc_tgt();


    void data_mspw_proc_tgt();


    void process_0_process_2();


    void update_input_queue( bool synch_phase = true );


    void update_event_queue();


    void flag_elaboration();


    void synch_elaboration();


    void simulate( memory_iostruct * io_exchange, int32_t & cycles_number );


    void start_of_simulation();


    void initialize();


    void finalize();

    const uint32_t ACCELEROMETER_HIGH_ADDRESS;
    const uint32_t ACCELEROMETER_LOW_ADDRESS;
    const uint32_t DATA_HIGH_ADDRESS;
    const uint32_t DATA_LOW_ADDRESS;
    const uint32_t RESULT_HIGH_ADDRESS;
    const uint32_t RESULT_LOW_ADDRESS;
    const uint32_t DATA_RDY_ADDRESS;
    const uint32_t RESULT_RDY_ADDRESS;
    const uint8_t ST_START;
    const uint8_t ST_1;
    const uint8_t ST_2;
    const uint8_t ST_3;
    const uint8_t ST_4;
    const uint8_t ST_5;
    const uint8_t ST_6;
    const uint8_t ST_7;
    const uint8_t ST_8;
    const uint8_t ST_9;
    const uint8_t ST_10;
    const uint8_t ST_11;
    const uint8_t ST_12;
    const uint8_t ST_13;
    const uint8_t ST_14;
    const uint8_t ST_15;


private:

    memory( const memory & );
    const memory& operator= ( const memory & );



};


#endif

